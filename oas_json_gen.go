// Code generated by ogen, DO NOT EDIT.

package ovt

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Error) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{

		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (s ErrorCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ErrorCode from json.
func (s *ErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ErrorCode(v) {
	case ErrorCodeBadRequestError:
		*s = ErrorCodeBadRequestError
	case ErrorCodeWrongCredentialsError:
		*s = ErrorCodeWrongCredentialsError
	case ErrorCodeAuthenticationRequiredError:
		*s = ErrorCodeAuthenticationRequiredError
	case ErrorCodeTooManyRequestsError:
		*s = ErrorCodeTooManyRequestsError
	case ErrorCodeForbiddenError:
		*s = ErrorCodeForbiddenError
	case ErrorCodeNotFoundError:
		*s = ErrorCodeNotFoundError
	case ErrorCodeQuotaExceededError:
		*s = ErrorCodeQuotaExceededError
	case ErrorCodeUserNotActiveError:
		*s = ErrorCodeUserNotActiveError
	case ErrorCodeInvalidArgumentError:
		*s = ErrorCodeInvalidArgumentError
	case ErrorCodeAlreadyExistsError:
		*s = ErrorCodeAlreadyExistsError
	case ErrorCodeTransientError:
		*s = ErrorCodeTransientError
	case ErrorCodeUnselectiveContentQueryError:
		*s = ErrorCodeUnselectiveContentQueryError
	case ErrorCodeUnsupportedContentQueryError:
		*s = ErrorCodeUnsupportedContentQueryError
	case ErrorCodeNotAvailableYet:
		*s = ErrorCodeNotAvailableYet
	case ErrorCodeFailedDependencyError:
		*s = ErrorCodeFailedDependencyError
	case ErrorCodeDeadlineExceededError:
		*s = ErrorCodeDeadlineExceededError
	default:
		*s = ErrorCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileInfoBadRequest) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfFileInfoBadRequest = [1]string{
	0: "error",
}

// Decode decodes FileInfoBadRequest from json.
func (s *FileInfoBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileInfoBadRequest) {
					name = jsonFieldsNameOfFileInfoBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileInfoOK) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfFileInfoOK = [1]string{
	0: "data",
}

// Decode decodes FileInfoOK from json.
func (s *FileInfoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileInfoOK) {
					name = jsonFieldsNameOfFileInfoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoOKData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileInfoOKData) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("links")
		s.Links.Encode(e)
	}
	{
		if s.Relationships.Set {
			e.FieldStart("relationships")
			s.Relationships.Encode(e)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFileInfoOKData = [5]string{
	0: "attributes",
	1: "id",
	2: "links",
	3: "relationships",
	4: "type",
}

// Decode decodes FileInfoOKData from json.
func (s *FileInfoOKData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOKData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "relationships":
			if err := func() error {
				s.Relationships.Reset()
				if err := s.Relationships.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationships\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoOKData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileInfoOKData) {
					name = jsonFieldsNameOfFileInfoOKData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOKData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOKData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoOKDataLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileInfoOKDataLinks) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("self")
		e.Str(s.Self)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfFileInfoOKDataLinks = [1]string{
	0: "self",
}

// Decode decodes FileInfoOKDataLinks from json.
func (s *FileInfoOKDataLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOKDataLinks to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Self = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoOKDataLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileInfoOKDataLinks) {
					name = jsonFieldsNameOfFileInfoOKDataLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOKDataLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOKDataLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoOKDataLinksAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FileInfoOKDataLinksAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FileInfoOKDataLinksAdditional from json.
func (s *FileInfoOKDataLinksAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOKDataLinksAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoOKDataLinksAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOKDataLinksAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOKDataLinksAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileInfoOKDataRelationships) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FileInfoOKDataRelationships) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FileInfoOKDataRelationships from json.
func (s *FileInfoOKDataRelationships) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOKDataRelationships to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfoOKDataRelationships")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOKDataRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOKDataRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileInfoOKDataType as json.
func (s FileInfoOKDataType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FileInfoOKDataType from json.
func (s *FileInfoOKDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoOKDataType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FileInfoOKDataType(v) {
	case FileInfoOKDataTypeFile:
		*s = FileInfoOKDataTypeFile
	default:
		*s = FileInfoOKDataType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoOKDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoOKDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileObject) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("capabilities_tags")
		e.ArrStart()
		for _, elem := range s.CapabilitiesTags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("creation_date")
		e.Int(s.CreationDate)
	}
	{

		e.FieldStart("downloadable")
		e.Bool(s.Downloadable)
	}
	{

		e.FieldStart("first_submission_date")
		e.Int(s.FirstSubmissionDate)
	}
	{

		e.FieldStart("last_analysis_date")
		e.Int(s.LastAnalysisDate)
	}
	{

		e.FieldStart("last_analysis_results")
		s.LastAnalysisResults.Encode(e)
	}
	{

		e.FieldStart("last_analysis_stats")
		s.LastAnalysisStats.Encode(e)
	}
	{

		e.FieldStart("last_modification_date")
		e.Int(s.LastModificationDate)
	}
	{

		e.FieldStart("last_submission_date")
		e.Int(s.LastSubmissionDate)
	}
	{

		e.FieldStart("main_icon")
		s.MainIcon.Encode(e)
	}
	{

		e.FieldStart("md5")
		e.Str(s.MD5)
	}
	{

		e.FieldStart("meaningful_name")
		e.Str(s.MeaningfulName)
	}
	{

		e.FieldStart("names")
		e.ArrStart()
		for _, elem := range s.Names {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("reputation")
		e.Int(s.Reputation)
	}
	{

		e.FieldStart("sha1")
		e.Str(s.SHA1)
	}
	{

		e.FieldStart("sha256")
		e.Str(s.SHA256)
	}
	{

		e.FieldStart("sigma_analysis_summary")
		s.SigmaAnalysisSummary.Encode(e)
	}
	{

		e.FieldStart("size")
		e.Int(s.Size)
	}
	{

		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("times_submitted")
		e.Int(s.TimesSubmitted)
	}
	{

		e.FieldStart("total_votes")
		s.TotalVotes.Encode(e)
	}
	{

		e.FieldStart("type_description")
		e.Str(s.TypeDescription)
	}
	{

		e.FieldStart("type_extension")
		e.Str(s.TypeExtension)
	}
	{

		e.FieldStart("type_tag")
		e.Str(s.TypeTag)
	}
	{

		e.FieldStart("unique_sources")
		e.Int(s.UniqueSources)
	}
	{

		e.FieldStart("vhash")
		e.Str(s.Vhash)
	}
}

var jsonFieldsNameOfFileObject = [26]string{
	0:  "capabilities_tags",
	1:  "creation_date",
	2:  "downloadable",
	3:  "first_submission_date",
	4:  "last_analysis_date",
	5:  "last_analysis_results",
	6:  "last_analysis_stats",
	7:  "last_modification_date",
	8:  "last_submission_date",
	9:  "main_icon",
	10: "md5",
	11: "meaningful_name",
	12: "names",
	13: "reputation",
	14: "sha1",
	15: "sha256",
	16: "sigma_analysis_summary",
	17: "size",
	18: "tags",
	19: "times_submitted",
	20: "total_votes",
	21: "type_description",
	22: "type_extension",
	23: "type_tag",
	24: "unique_sources",
	25: "vhash",
}

// Decode decodes FileObject from json.
func (s *FileObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObject to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capabilities_tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CapabilitiesTags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CapabilitiesTags = append(s.CapabilitiesTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities_tags\"")
			}
		case "creation_date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreationDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creation_date\"")
			}
		case "downloadable":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Downloadable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadable\"")
			}
		case "first_submission_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.FirstSubmissionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_submission_date\"")
			}
		case "last_analysis_date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.LastAnalysisDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_date\"")
			}
		case "last_analysis_results":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.LastAnalysisResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_results\"")
			}
		case "last_analysis_stats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.LastAnalysisStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_stats\"")
			}
		case "last_modification_date":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.LastModificationDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_modification_date\"")
			}
		case "last_submission_date":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.LastSubmissionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_submission_date\"")
			}
		case "main_icon":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.MainIcon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"main_icon\"")
			}
		case "md5":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MD5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"md5\"")
			}
		case "meaningful_name":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MeaningfulName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meaningful_name\"")
			}
		case "names":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "reputation":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Reputation = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation\"")
			}
		case "sha1":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.SHA1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha1\"")
			}
		case "sha256":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SHA256 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha256\"")
			}
		case "sigma_analysis_summary":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.SigmaAnalysisSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sigma_analysis_summary\"")
			}
		case "size":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "tags":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "times_submitted":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TimesSubmitted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"times_submitted\"")
			}
		case "total_votes":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TotalVotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_votes\"")
			}
		case "type_description":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TypeDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type_description\"")
			}
		case "type_extension":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TypeExtension = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type_extension\"")
			}
		case "type_tag":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TypeTag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type_tag\"")
			}
		case "unique_sources":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.UniqueSources = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_sources\"")
			}
		case "vhash":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Vhash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vhash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileObject) {
					name = jsonFieldsNameOfFileObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObjectLastAnalysisResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FileObjectLastAnalysisResults) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FileObjectLastAnalysisResults from json.
func (s *FileObjectLastAnalysisResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObjectLastAnalysisResults to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObjectLastAnalysisResults")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObjectLastAnalysisResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObjectLastAnalysisResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObjectLastAnalysisStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FileObjectLastAnalysisStats) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FileObjectLastAnalysisStats from json.
func (s *FileObjectLastAnalysisStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObjectLastAnalysisStats to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObjectLastAnalysisStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObjectLastAnalysisStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObjectLastAnalysisStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObjectMainIcon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileObjectMainIcon) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("dhash")
		e.Str(s.Dhash)
	}
	{

		e.FieldStart("raw_md5")
		e.Str(s.RawMD5)
	}
}

var jsonFieldsNameOfFileObjectMainIcon = [2]string{
	0: "dhash",
	1: "raw_md5",
}

// Decode decodes FileObjectMainIcon from json.
func (s *FileObjectMainIcon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObjectMainIcon to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dhash":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Dhash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dhash\"")
			}
		case "raw_md5":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RawMD5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_md5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObjectMainIcon")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileObjectMainIcon) {
					name = jsonFieldsNameOfFileObjectMainIcon[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObjectMainIcon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObjectMainIcon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObjectSigmaAnalysisSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FileObjectSigmaAnalysisSummary) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FileObjectSigmaAnalysisSummary from json.
func (s *FileObjectSigmaAnalysisSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObjectSigmaAnalysisSummary to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObjectSigmaAnalysisSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObjectSigmaAnalysisSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObjectSigmaAnalysisSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FileObjectTotalVotes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FileObjectTotalVotes) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("harmless")
		e.Int(s.Harmless)
	}
	{

		e.FieldStart("malicious")
		e.Int(s.Malicious)
	}
}

var jsonFieldsNameOfFileObjectTotalVotes = [2]string{
	0: "harmless",
	1: "malicious",
}

// Decode decodes FileObjectTotalVotes from json.
func (s *FileObjectTotalVotes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileObjectTotalVotes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "harmless":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Harmless = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harmless\"")
			}
		case "malicious":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Malicious = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malicious\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileObjectTotalVotes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileObjectTotalVotes) {
					name = jsonFieldsNameOfFileObjectTotalVotes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileObjectTotalVotes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileObjectTotalVotes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileInfoOKDataRelationships as json.
func (o OptFileInfoOKDataRelationships) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileInfoOKDataRelationships from json.
func (o *OptFileInfoOKDataRelationships) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileInfoOKDataRelationships to nil")
	}
	o.Set = true
	o.Value = make(FileInfoOKDataRelationships)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileInfoOKDataRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileInfoOKDataRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes URLInfoOKDataRelationships as json.
func (o OptURLInfoOKDataRelationships) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes URLInfoOKDataRelationships from json.
func (o *OptURLInfoOKDataRelationships) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURLInfoOKDataRelationships to nil")
	}
	o.Set = true
	o.Value = make(URLInfoOKDataRelationships)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURLInfoOKDataRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURLInfoOKDataRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLInfoBadRequest) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfURLInfoBadRequest = [1]string{
	0: "error",
}

// Decode decodes URLInfoBadRequest from json.
func (s *URLInfoBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLInfoBadRequest) {
					name = jsonFieldsNameOfURLInfoBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLInfoOK) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfURLInfoOK = [1]string{
	0: "data",
}

// Decode decodes URLInfoOK from json.
func (s *URLInfoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLInfoOK) {
					name = jsonFieldsNameOfURLInfoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoOKData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLInfoOKData) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("links")
		s.Links.Encode(e)
	}
	{
		if s.Relationships.Set {
			e.FieldStart("relationships")
			s.Relationships.Encode(e)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfURLInfoOKData = [5]string{
	0: "attributes",
	1: "id",
	2: "links",
	3: "relationships",
	4: "type",
}

// Decode decodes URLInfoOKData from json.
func (s *URLInfoOKData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOKData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "relationships":
			if err := func() error {
				s.Relationships.Reset()
				if err := s.Relationships.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationships\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoOKData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLInfoOKData) {
					name = jsonFieldsNameOfURLInfoOKData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOKData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOKData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoOKDataLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLInfoOKDataLinks) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("self")
		e.Str(s.Self)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfURLInfoOKDataLinks = [1]string{
	0: "self",
}

// Decode decodes URLInfoOKDataLinks from json.
func (s *URLInfoOKDataLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOKDataLinks to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Self = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoOKDataLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLInfoOKDataLinks) {
					name = jsonFieldsNameOfURLInfoOKDataLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOKDataLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOKDataLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoOKDataLinksAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLInfoOKDataLinksAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLInfoOKDataLinksAdditional from json.
func (s *URLInfoOKDataLinksAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOKDataLinksAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoOKDataLinksAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOKDataLinksAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOKDataLinksAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLInfoOKDataRelationships) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLInfoOKDataRelationships) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLInfoOKDataRelationships from json.
func (s *URLInfoOKDataRelationships) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOKDataRelationships to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLInfoOKDataRelationships")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOKDataRelationships) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOKDataRelationships) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes URLInfoOKDataType as json.
func (s URLInfoOKDataType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes URLInfoOKDataType from json.
func (s *URLInfoOKDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLInfoOKDataType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch URLInfoOKDataType(v) {
	case URLInfoOKDataTypeURL:
		*s = URLInfoOKDataTypeURL
	default:
		*s = URLInfoOKDataType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLInfoOKDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLInfoOKDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObject) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("categories")
		s.Categories.Encode(e)
	}
	{

		e.FieldStart("favicon")
		s.Favicon.Encode(e)
	}
	{

		e.FieldStart("first_submission_date")
		e.Int(s.FirstSubmissionDate)
	}
	{

		e.FieldStart("html_meta")
		s.HTMLMeta.Encode(e)
	}
	{

		e.FieldStart("last_analysis_date")
		e.Int(s.LastAnalysisDate)
	}
	{

		e.FieldStart("last_analysis_results")
		s.LastAnalysisResults.Encode(e)
	}
	{

		e.FieldStart("last_analysis_stats")
		s.LastAnalysisStats.Encode(e)
	}
	{

		e.FieldStart("last_final_url")
		e.Str(s.LastFinalURL)
	}
	{

		e.FieldStart("last_http_response_code")
		e.Int(s.LastHTTPResponseCode)
	}
	{

		e.FieldStart("last_http_response_content_length")
		e.Int(s.LastHTTPResponseContentLength)
	}
	{

		e.FieldStart("last_http_response_content_sha256")
		e.Str(s.LastHTTPResponseContentSHA256)
	}
	{

		e.FieldStart("last_http_response_cookies")
		s.LastHTTPResponseCookies.Encode(e)
	}
	{

		e.FieldStart("last_http_response_headers")
		s.LastHTTPResponseHeaders.Encode(e)
	}
	{

		e.FieldStart("last_modification_date")
		e.Int(s.LastModificationDate)
	}
	{

		e.FieldStart("last_submission_date")
		e.Int(s.LastSubmissionDate)
	}
	{

		e.FieldStart("outgoing_links")
		e.ArrStart()
		for _, elem := range s.OutgoingLinks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("redirection_chain")
		e.ArrStart()
		for _, elem := range s.RedirectionChain {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("reputation")
		e.Int(s.Reputation)
	}
	{

		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("targeted_brand")
		s.TargetedBrand.Encode(e)
	}
	{

		e.FieldStart("times_submitted")
		e.Int(s.TimesSubmitted)
	}
	{

		e.FieldStart("title")
		e.Str(s.Title)
	}
	{

		e.FieldStart("total_votes")
		s.TotalVotes.Encode(e)
	}
	{

		e.FieldStart("trackers")
		s.Trackers.Encode(e)
	}
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfURLObject = [25]string{
	0:  "categories",
	1:  "favicon",
	2:  "first_submission_date",
	3:  "html_meta",
	4:  "last_analysis_date",
	5:  "last_analysis_results",
	6:  "last_analysis_stats",
	7:  "last_final_url",
	8:  "last_http_response_code",
	9:  "last_http_response_content_length",
	10: "last_http_response_content_sha256",
	11: "last_http_response_cookies",
	12: "last_http_response_headers",
	13: "last_modification_date",
	14: "last_submission_date",
	15: "outgoing_links",
	16: "redirection_chain",
	17: "reputation",
	18: "tags",
	19: "targeted_brand",
	20: "times_submitted",
	21: "title",
	22: "total_votes",
	23: "trackers",
	24: "url",
}

// Decode decodes URLObject from json.
func (s *URLObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObject to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Categories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "favicon":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Favicon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favicon\"")
			}
		case "first_submission_date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FirstSubmissionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_submission_date\"")
			}
		case "html_meta":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLMeta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_meta\"")
			}
		case "last_analysis_date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.LastAnalysisDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_date\"")
			}
		case "last_analysis_results":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.LastAnalysisResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_results\"")
			}
		case "last_analysis_stats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.LastAnalysisStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_analysis_stats\"")
			}
		case "last_final_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LastFinalURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_final_url\"")
			}
		case "last_http_response_code":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.LastHTTPResponseCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_http_response_code\"")
			}
		case "last_http_response_content_length":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.LastHTTPResponseContentLength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_http_response_content_length\"")
			}
		case "last_http_response_content_sha256":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LastHTTPResponseContentSHA256 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_http_response_content_sha256\"")
			}
		case "last_http_response_cookies":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.LastHTTPResponseCookies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_http_response_cookies\"")
			}
		case "last_http_response_headers":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.LastHTTPResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_http_response_headers\"")
			}
		case "last_modification_date":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.LastModificationDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_modification_date\"")
			}
		case "last_submission_date":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.LastSubmissionDate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_submission_date\"")
			}
		case "outgoing_links":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.OutgoingLinks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OutgoingLinks = append(s.OutgoingLinks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outgoing_links\"")
			}
		case "redirection_chain":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				s.RedirectionChain = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RedirectionChain = append(s.RedirectionChain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redirection_chain\"")
			}
		case "reputation":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Reputation = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reputation\"")
			}
		case "tags":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "targeted_brand":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TargetedBrand.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targeted_brand\"")
			}
		case "times_submitted":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TimesSubmitted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"times_submitted\"")
			}
		case "title":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "total_votes":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.TotalVotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_votes\"")
			}
		case "trackers":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.Trackers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackers\"")
			}
		case "url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObject) {
					name = jsonFieldsNameOfURLObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectCategories) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLObjectCategories) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLObjectCategories from json.
func (s *URLObjectCategories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectCategories to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectCategories")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectCategories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectCategories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectFavicon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObjectFavicon) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("dhash")
		e.Str(s.Dhash)
	}
	{

		e.FieldStart("raw_md5")
		e.Str(s.RawMD5)
	}
}

var jsonFieldsNameOfURLObjectFavicon = [2]string{
	0: "dhash",
	1: "raw_md5",
}

// Decode decodes URLObjectFavicon from json.
func (s *URLObjectFavicon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectFavicon to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dhash":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Dhash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dhash\"")
			}
		case "raw_md5":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RawMD5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_md5\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectFavicon")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObjectFavicon) {
					name = jsonFieldsNameOfURLObjectFavicon[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectFavicon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectFavicon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectHTMLMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLObjectHTMLMeta) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLObjectHTMLMeta from json.
func (s *URLObjectHTMLMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectHTMLMeta to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectHTMLMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectHTMLMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectHTMLMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectLastAnalysisResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObjectLastAnalysisResults) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{

		e.FieldStart("engine_name")
		e.Str(s.EngineName)
	}
	{

		e.FieldStart("method")
		e.Str(s.Method)
	}
	{

		e.FieldStart("result")
		e.Str(s.Result)
	}
}

var jsonFieldsNameOfURLObjectLastAnalysisResults = [4]string{
	0: "category",
	1: "engine_name",
	2: "method",
	3: "result",
}

// Decode decodes URLObjectLastAnalysisResults from json.
func (s *URLObjectLastAnalysisResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectLastAnalysisResults to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "engine_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EngineName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"engine_name\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Method = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Result = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectLastAnalysisResults")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObjectLastAnalysisResults) {
					name = jsonFieldsNameOfURLObjectLastAnalysisResults[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectLastAnalysisResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectLastAnalysisResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes URLObjectLastAnalysisResultsCategory as json.
func (s URLObjectLastAnalysisResultsCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes URLObjectLastAnalysisResultsCategory from json.
func (s *URLObjectLastAnalysisResultsCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectLastAnalysisResultsCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch URLObjectLastAnalysisResultsCategory(v) {
	case URLObjectLastAnalysisResultsCategoryHarmless:
		*s = URLObjectLastAnalysisResultsCategoryHarmless
	case URLObjectLastAnalysisResultsCategoryUndetected:
		*s = URLObjectLastAnalysisResultsCategoryUndetected
	case URLObjectLastAnalysisResultsCategorySuspicious:
		*s = URLObjectLastAnalysisResultsCategorySuspicious
	case URLObjectLastAnalysisResultsCategoryMalicious:
		*s = URLObjectLastAnalysisResultsCategoryMalicious
	default:
		*s = URLObjectLastAnalysisResultsCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectLastAnalysisResultsCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectLastAnalysisResultsCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectLastAnalysisStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObjectLastAnalysisStats) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("harmless")
		e.Int(s.Harmless)
	}
	{

		e.FieldStart("malicious")
		e.Int(s.Malicious)
	}
	{

		e.FieldStart("suspicious")
		e.Int(s.Suspicious)
	}
	{

		e.FieldStart("timeout")
		e.Int(s.Timeout)
	}
	{

		e.FieldStart("undetected")
		e.Int(s.Undetected)
	}
}

var jsonFieldsNameOfURLObjectLastAnalysisStats = [5]string{
	0: "harmless",
	1: "malicious",
	2: "suspicious",
	3: "timeout",
	4: "undetected",
}

// Decode decodes URLObjectLastAnalysisStats from json.
func (s *URLObjectLastAnalysisStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectLastAnalysisStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "harmless":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Harmless = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harmless\"")
			}
		case "malicious":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Malicious = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malicious\"")
			}
		case "suspicious":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Suspicious = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspicious\"")
			}
		case "timeout":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Timeout = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "undetected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Undetected = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"undetected\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectLastAnalysisStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObjectLastAnalysisStats) {
					name = jsonFieldsNameOfURLObjectLastAnalysisStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectLastAnalysisStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectLastAnalysisStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectLastHTTPResponseCookies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLObjectLastHTTPResponseCookies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLObjectLastHTTPResponseCookies from json.
func (s *URLObjectLastHTTPResponseCookies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectLastHTTPResponseCookies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectLastHTTPResponseCookies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectLastHTTPResponseCookies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectLastHTTPResponseCookies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectLastHTTPResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLObjectLastHTTPResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLObjectLastHTTPResponseHeaders from json.
func (s *URLObjectLastHTTPResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectLastHTTPResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectLastHTTPResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectLastHTTPResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectLastHTTPResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectTargetedBrand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s URLObjectTargetedBrand) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes URLObjectTargetedBrand from json.
func (s *URLObjectTargetedBrand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectTargetedBrand to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectTargetedBrand")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectTargetedBrand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectTargetedBrand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectTotalVotes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObjectTotalVotes) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("harmless")
		e.Int(s.Harmless)
	}
	{

		e.FieldStart("malicious")
		e.Int(s.Malicious)
	}
}

var jsonFieldsNameOfURLObjectTotalVotes = [2]string{
	0: "harmless",
	1: "malicious",
}

// Decode decodes URLObjectTotalVotes from json.
func (s *URLObjectTotalVotes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectTotalVotes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "harmless":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Harmless = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"harmless\"")
			}
		case "malicious":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Malicious = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"malicious\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectTotalVotes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObjectTotalVotes) {
					name = jsonFieldsNameOfURLObjectTotalVotes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectTotalVotes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectTotalVotes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s URLObjectTrackers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s URLObjectTrackers) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("timestamp")
		e.Int(s.Timestamp)
	}
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfURLObjectTrackers = [3]string{
	0: "id",
	1: "timestamp",
	2: "url",
}

// Decode decodes URLObjectTrackers from json.
func (s *URLObjectTrackers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode URLObjectTrackers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Timestamp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode URLObjectTrackers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfURLObjectTrackers) {
					name = jsonFieldsNameOfURLObjectTrackers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s URLObjectTrackers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *URLObjectTrackers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
